抱歉，上一条没有按 Markdown 呈现。下面是同内容的 Markdown 版《审批.md》。

# 审批.md

## 一、目标与范围
- 基于 flow_template/flow_node_template 定义审批模板（树形结构），实例化为 flow/flow_node/flow_node_task 并驱动流转。
- 支持节点类型：condition/approval/cc/subflow，含规则解析、任务分配、回调与子流程。
- 目标：扩展性（可增节点/规则）、稳定性（并发/幂等）、可观测性（回调/审计）。

## 二、核心设计模式与落地点

1. 组合模式 Composite
   - 用途：表达模板与实例的树形结构（父子/分支）。
   - 落地：FlowNodeTemplate::children 递归；运行期按树推进。

2. 构建者 + 原型 + 备忘录 Builder + Prototype + Memento
   - 用途：模板 → 实例化节点/任务；保存模板快照避免历史受影响。
   - 落地：FlowBuilder 从模板树构建 flow/flow_node/flow_node_task；flow.flow_node_template_snapshot 存快照。

3. 职责链 Chain of Responsibility
   - 用途：节点按顺序/分支推进；完成后传递到下一可达节点。
   - 落地：FlowEngine 按节点结果选择并派发下一个节点。

4. 策略模式 + 规格模式 Strategy + Specification
   - 用途：规则可配置且可组合（阈值、角色、任一/会签等）。
   - 落地：RuleEvaluatorInterface + 规格组合（And/Or/Not/Threshold/Role…）。

5. 状态模式 State
   - 用途：Flow/FlowNode/FlowNodeTask 的状态机管理。
   - 落地：FlowState/NodeState/TaskState 封装允许的转移与副作用。

6. 模板方法 Template Method
   - 用途：统一节点生命周期，子类覆盖差异化行为。
   - 落地：BaseNodeHandler 定义 enter → execute → complete → after；各节点类型实现 execute/after。

7. 工厂模式 Factory
   - 用途：按节点/规则类型创建处理器/规则求值器/审批人解析器。
   - 落地：NodeHandlerFactory、RuleEvaluatorFactory、AssigneeResolverFactory。

8. 命令模式 Command
   - 用途：封装用户操作（发起/同意/驳回/撤回/转交），便于审计、幂等、异步。
   - 落地：ApproveCommand/RejectCommand/RecallCommand + Handler（内含事务）。

9. 观察者/领域事件 Observer/Domain Event（可配合 Outbox）
   - 用途：流转事件触发回调/通知/Webhook。
   - 落地：发布 FlowApproved/NodeRejected 等事件；Subscriber 推送外部回调；Outbox 确保可靠。

10. 仓储 Repository + 工作单元/事务 Unit of Work
    - 用途：隔离数据访问、在关键流转中保证一致性。
    - 落地：现有 Repositories；Service/CommandHandler 中 DB::transaction。

11. 适配器 Adapter
    - 用途：对接外部用户/组织/财务系统与回调协议。
    - 落地：UserDirectoryAdapter、WebhookAdapter。

12. 编排/Saga（子流程可选）
    - 用途：子流程 orchestration 与失败补偿。
    - 落地：SubflowNodeHandler 创建并监听子流程完成；跨服务时可用 Saga。

## 三、目录结构建议（Laravel）
```
app/
  Services/
    FlowService.php
    Engine/FlowEngine.php
    Builder/FlowBuilder.php
  Domain/
    Node/
      BaseNodeHandler.php
      ConditionNodeHandler.php
      ApprovalNodeHandler.php
      CcNodeHandler.php
      SubflowNodeHandler.php
      NodeHandlerFactory.php
    Rules/
      RuleEvaluatorInterface.php
      RuleEvaluatorFactory.php
      Specification/
        AndSpec.php
        OrSpec.php
        NotSpec.php
        ThresholdSpec.php
        RoleSpec.php
      AssigneeResolverFactory.php
    State/
      FlowState.php
      NodeState.php
      TaskState.php
    Commands/
      ApproveCommand.php
      RejectCommand.php
      RecallCommand.php
      Handlers/...
    Events/
      FlowApproved.php
      NodeRejected.php
      Subscribers/
        WebhookSubscriber.php
        NotificationSubscriber.php
repositories/（已存在）
```

## 四、关键接口与代码骨架

### 4.1 节点处理器（模板方法 + 工厂 + 职责链）
```php
<?php
interface NodeHandlerInterface {
    public function enter(Flow $flow, FlowNode $node, array $context = []): void;
    public function execute(Flow $flow, FlowNode $node, array $context = []): NodeResult;
    public function complete(Flow $flow, FlowNode $node, NodeResult $result): void;
}

abstract class BaseNodeHandler implements NodeHandlerInterface {
    public function enter(Flow $flow, FlowNode $node, array $context = []): void {
        // 将节点置为 process，必要时创建待办任务
    }
    public function complete(Flow $flow, FlowNode $node, NodeResult $result): void {
        // 更新节点状态；发布领域事件；交给引擎推进下一节点
    }
}

final class ApprovalNodeHandler extends BaseNodeHandler {
    public function execute(Flow $flow, FlowNode $node, array $context = []): NodeResult {
        // 依据 rules 分配审批人，创建 flow_node_task（会签或或签）
        return NodeResult::waiting(); // 等待用户操作
    }
}

final class ConditionNodeHandler extends BaseNodeHandler {
    public function execute(Flow $flow, FlowNode $node, array $context = []): NodeResult {
        // RuleEvaluator 评估条件，返回命中分支的下一节点
        return NodeResult::next([$nextNodeId]);
    }
}

final class NodeHandlerFactory {
    public static function make(string $type): NodeHandlerInterface {
        return match ($type) {
            'approval'  => app(ApprovalNodeHandler::class),
            'condition' => app(ConditionNodeHandler::class),
            'cc'        => app(CcNodeHandler::class),
            'subflow'   => app(SubflowNodeHandler::class),
            default     => throw new InvalidArgumentException("Unknown node type: {$type}"),
        };
    }
}
```

### 4.2 规则评估（策略 + 规格）
```php
<?php
interface RuleEvaluatorInterface {
    public function evaluate(array $rules, array $context): RuleResult; // 命中分支/通过条件/候选人解析
}

final class RuleEvaluatorFactory {
    public static function make(?string $type): RuleEvaluatorInterface {
        return match ($type) {
            'threshold' => app(\App\Domain\Rules\Specification\ThresholdSpec::class),
            'role'      => app(\App\Domain\Rules\Specification\RoleSpec::class),
            default     => app(\App\Domain\Rules\Specification\CompositeSpec::class),
        };
    }
}
```

### 4.3 引擎（职责链 + 状态）
```php
<?php
final class FlowEngine {
    public function start(Flow $flow): void {
        DB::transaction(function () use ($flow) {
            $entryNodes = $this->selectEntryNodes($flow);
            foreach ($entryNodes as $node) {
                $this->dispatch($flow, $node);
            }
            $flow->update(['status' => 'process']);
        });
    }

    public function onTaskApproved(FlowNodeTask $task, array $op): void {
        DB::transaction(function () use ($task, $op) {
            // 任务置为 approve；若会签满足条件则节点 approve；选择下一节点并派发
        });
    }

    private function dispatch(Flow $flow, FlowNode $node): void {
        $handler = NodeHandlerFactory::make($node->type);
        $handler->enter($flow, $node);
        $result = $handler->execute($flow, $node);
        if ($result->isImmediate()) {
            $handler->complete($flow, $node, $result);
        }
    }

    private function selectEntryNodes(Flow $flow): array {
        // 从 depth=1 或模板标记的起点选取
        return FlowNode::query()->where('flow_id', $flow->id)->where('depth', 1)->get()->all();
    }
}
```

### 4.4 构建器（模板 → 实例：构建者 + 原型 + 备忘录）
```php
<?php
final class FlowBuilder {
    public function buildFromTemplate(FlowTemplate $template, array $input): Flow {
        return DB::transaction(function () use ($template, $input) {
            // 1) 读取模板树（含 children）
            $rootTemplates = FlowNodeTemplate::query()
                ->where('flow_template_id', $template->id)
                ->whereNull('parent_id')
                ->with('children')
                ->get();

            // 2) 保存流程+快照
            $snapshot = $rootTemplates->toArray();
            $flow = Flow::query()->create([
                'parent_id'                   => $input['parent_id'] ?? null,
                'title'                       => $input['title'],
                'business_type'               => $template->type,
                'business_id'                 => $input['business_id'],
                'status'                      => 'create',
                'flow_node_template_snapshot' => $snapshot,
                'callback'                    => $template->callback ?? [],
                'applicant_type'              => $input['applicant_type'] ?? 'user',
                'applicant_id'                => $input['applicant_id'],
                'extend'                      => $input['extend'] ?? [],
                'flow_template_id'            => $template->id,
            ]);

            // 3) 递归展开模板 → 实例节点
            $queue = collect();
            $push = function ($tpl, $parentId = null) use (&$push, $flow, $queue) {
                $node = FlowNode::query()->create([
                    'parent_id' => $parentId,
                    'depth'     => $tpl['depth'],
                    'name'      => $tpl['name'],
                    'type'      => $tpl['type'],
                    'rules'     => $tpl['rules'] ?? [],
                    'status'    => 'process', // 初始派发时再调整
                    'callback'  => $tpl['callback'] ?? [],
                    'flow_id'   => $flow->id,
                    'extend'    => [],
                ]);
                foreach ($tpl['children'] ?? [] as $child) {
                    $push($child, $node->id);
                }
                return $node;
            };
            foreach ($rootTemplates as $tpl) { $push($tpl->toArray(), null); }

            return $flow;
        });
    }
}
```

### 4.5 命令模式（审批准入/拒绝等）
```php
<?php
final class ApproveCommand {
    public function __construct(public string $taskId, public array $operation = []) {}
}
final class ApproveCommandHandler {
    public function __invoke(ApproveCommand $cmd): void {
        DB::transaction(function () use ($cmd) {
            $task = FlowNodeTask::lockForUpdate()->findOrFail($cmd->taskId);
            // 幂等检查
            if ($task->status !== 'process') return;
            $task->update(['status' => 'approve', 'operation_info' => $cmd->operation]);
            // 交给引擎推进
            app(FlowEngine::class)->onTaskApproved($task, $cmd->operation);
        });
    }
}
```

## 五、服务层与控制器建议

- FlowService::create
  - 校验模板启用状态；
  - FlowBuilder 构建实例；
  - FlowEngine 启动流程；
  - 返回 flow 基本信息。

```php
<?php
final class FlowService
{
    public function __construct(
        private FlowRepositories $flows,
    ) {}

    public function create(string $type, array $inputs): JsonResponse
    {
        try {
            $template = FlowTemplate::query()
                ->where('type', $type)
                ->where('status', 'enable')
                ->firstOrFail();

            $flow = app(FlowBuilder::class)->buildFromTemplate($template, $inputs);
            app(FlowEngine::class)->start($flow);

            return ApiResponse::success(['flow_id' => $flow->id, 'status' => $flow->status]);
        } catch (\Throwable $e) {
            return ApiResponse::fail(message: $e->getMessage());
        }
    }
}
```

## 六、并发、事务与幂等
- 所有状态变更操作使用 DB::transaction 包裹。
- 同一 flow/node 并发：建议增加 version 字段做乐观锁，或基于 flow_id 的分布式锁。
- 幂等：
  - task 层：仅允许 process → {approve|reject|skip|cancel} 一次性转移，重复请求直接返回最终态。
  - 对外回调：Outbox 表 + 消费者推送，失败重试。

## 七、回调与通知（观察者/事件）
- 事件：FlowStarted/FlowApproved/FlowRejected/NodeApproved/NodeRejected/TaskCreated 等。
- 订阅者：WebhookSubscriber 根据 flow/node 的 callback 字段推送；NotificationSubscriber 发站内/IM 通知。
- WebhookAdapter 统一签名、重试、超时策略。

## 八、子流程 Subflow（可选）
- SubflowNodeHandler 创建子流程（flow.parent_id = 父流程 id）。
- 监听子流程完成事件后，将父流程对应节点置为 approve 并推进。
- 跨服务编排可引入 Saga，提供补偿逻辑。

## 九、可扩展点
- 新增节点类型：实现 NodeHandlerInterface，并在 NodeHandlerFactory 注册。
- 新增规则：实现 RuleEvaluatorInterface 或 Specification，并在 RuleEvaluatorFactory 注册。
- 新增审批人解析策略：扩展 AssigneeResolverFactory（如按角色、上级、动态字段）。

## 十、与当前模型/仓库字段对齐建议（重要）
你提供的迁移表与模型/仓库存在若干命名不一致，建议先统一，否则运行期会报错：

- 模型表名
  - FlowTemplate::$table 应为 flow_template（当前为 approval_template）。
  - FlowNodeTemplate::$table 应为 flow_node_template（当前为 approval_node_template）。
- FlowRepositories.store 字段
  - 移除 flow_code、node_template_snapshot、template_id；
  - 使用迁移中的 title、flow_node_template_snapshot、flow_template_id。
- FlowNodeRepositories.store 字段
  - approval_id 改为 flow_id。
- FlowNodeTaskRepositories.store 字段
  - approval_node_id 改为 flow_node_id。
- FlowTemplateRepositories.page
  - where('flow_code', ...) 改为 where('type', ...)。
- FlowTemplate 关联
  - nodeTemplate() 外键应为 flow_template_id 对应 template 的 id，或改名一致。

以上对齐完成后再接入引擎与模式代码。

## 十一、小结
- 用组合构树、构建者/原型/备忘录实例化、职责链推进、策略/规格评估规则、状态机管控状态、模板方法统一节点生命周期、工厂装配处理器、命令封装动作、观察者对外回调、仓储+事务保一致、适配器对接外部、Saga 处理子流程。分工清晰、扩展容易、可稳定支撑你的审批服务。

如需，我可以基于以上骨架继续补充最小可运行版本的类文件清单与方法实现。